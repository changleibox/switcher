<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, user-scalable=no">
  <meta name="generator" content="made with love by dartdoc 0.30.4">
  <meta name="description" content="switcher API docs, for the Dart programming language.">
  <title>switcher - Dart API docs</title>

  
  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500,400i,400,300|Source+Sans+Pro:400,300,700" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="static-assets/github.css">
  <link rel="stylesheet" href="static-assets/styles.css">
  <link rel="icon" href="static-assets/favicon.png">

</head>

<body data-base-href=""
      data-using-base-href="false">

<div id="overlay-under-drawer"></div>

<header id="title">
  <button id="sidenav-left-toggle" type="button">&nbsp;</button>
  <ol class="breadcrumbs gt-separated dark hidden-xs">
    <li><a href="https://github.com/changleibox/flutter_switcher">switcher package</a></li>
  </ol>
  <div class="self-name">switcher</div>
  <form class="search navbar-right" role="search">
    <input type="text" id="search-box" autocomplete="off" disabled class="form-control typeahead" placeholder="Loading search...">
  </form>
</header>

<main>

  <div id="dartdoc-sidebar-left" class="col-xs-6 col-sm-3 col-md-2 sidebar sidebar-offcanvas-left">
    <header id="header-search-sidebar" class="hidden-l">
      <form class="search-sidebar" role="search">
        <input type="text" id="search-sidebar" autocomplete="off" disabled class="form-control typeahead" placeholder="Loading search...">
      </form>
    </header>
    
    <ol class="breadcrumbs gt-separated dark hidden-l" id="sidebar-nav">
      <li><a href="https://github.com/changleibox/flutter_switcher">switcher package</a></li>
    </ol>
    
    <h5 class="hidden-xs"><span class="package-name">switcher</span> <span class="package-kind">package</span></h5>
    <ol>
          <li class="section-title">Libraries</li>
          <li><a href="switcher/switcher-library.html">switcher</a></li>
    </ol>
  </div>

  <div id="dartdoc-main-content" class="col-xs-12 col-sm-9 col-md-8 main-content">
      <section class="desc markdown">
        <h2 id="">简介</h2>
<p>本文介绍怎么在Flutter里使用ListView实现Android的跑马灯，然后再扩展一下，实现上下滚动。</p>
<p>该小控件已经成功上传到<a href="https://pub.dev/packages/" title="pub.dev">pub.dev</a>，安装方式：</p>
<pre class="language-markdown"><code class="language-markdown">dependencies:
   switcher: ^1.0.0+1
</code></pre>
<h3 id="-2">效果图</h3>
<p>先上效果图：</p>
<h5 id="-3">垂直模式</h5>
<p><img src="https://oscimg.oschina.net/oscnet/up-1c791c2c924e74f0ad5da76e712b6c5b812.gif" alt="垂直滚动"></p>
<h5 id="-4">水平模式</h5>
<p><img src="https://oscimg.oschina.net/oscnet/up-fc4bde67866cda1f6aa97d4cdb093ddde80.gif" alt="水平滚动"></p>
<h2 id="-5">上代码</h2>
<p>主要有两种滚动模式，垂直模式和水平模式，所以我们定义两个构造方法。
参数分别有滚动速度（单位是<code>pixels/second</code>）、每次滚动的延迟、滚动的曲线变化和<code>children</code>为空的时候的占位控件。</p>
<pre class="language-dart"><code class="language-dart">class Switcher {
  const Switcher.vertical({
    Key key,
    @required this.children,
    this.scrollDelta = _kScrollDelta,
    this.delayedDuration = _kDelayedDuration,
    this.curve = Curves.linearToEaseOut,
    this.placeholder,
  })  : assert(scrollDelta != null &amp;&amp; scrollDelta &gt; 0 &amp;&amp; scrollDelta &lt;= _kMaxScrollDelta),
        assert(delayDuration != null),
        assert(curve != null),
        spacing = 0,
        _scrollDirection = Axis.vertical,
        super(key: key);
  
  const Switcher.horizontal({
    Key key,
    @required this.children,
    this.scrollDelta = _kScrollDelta,
    this.delayedDuration = _kDelayedDuration,
    this.curve = Curves.linear,
    this.placeholder,
    this.spacing = 10,
  })  : assert(scrollDelta != null &amp;&amp; scrollDelta &gt; 0 &amp;&amp; scrollDelta &lt;= _kMaxScrollDelta),
        assert(delayDuration != null),
        assert(curve != null),
        assert(spacing != null &amp;&amp; spacing &gt;= 0 &amp;&amp; spacing &lt; double.infinity),
        _scrollDirection = Axis.horizontal,
        super(key: key);
}
</code></pre>
<h3 id="-6">实现思路</h3>
<p>实现思路有两种：</p>
<ul>
<li>
<p>第一种是用<code>ListView</code>；</p>
</li>
<li>
<p>第二种是用<code>CustomPaint</code>自己画；</p>
</li>
</ul>
<p>这里我们选择用<code>ListView</code>方式实现，方便后期扩展可手动滚动，如果用<code>CustomPaint</code>，实现起来就比较麻烦。</p>
<p>接下来我们分析一下究竟该怎么实现：</p>
<h3 id="-7">垂直模式</h3>
<p>首先分析一下垂直模式，如果想实现循环滚动，那么<code>children</code>的数量就应该比原来的多一个，当滚动到最后一个的时候，立马跳到第一个，这里的最后一个实际就是原来的第一个，所以用户不会有任何察觉，这种实现方式在前端开发中应用很多，比如实现<code>PageView</code>的循环滑动，所以这里我们先定义<code>childCount</code>：</p>
<pre class="language-dart"><code class="language-dart">_initalizationElements() {
  _childCount = 0;
  if (widget.children != null) {
    _childCount = widget.children.length;
  }
  if (_childCount &gt; 0 &amp;&amp; widget._scrollDirection == Axis.vertical) {
    _childCount++;
  }
}
</code></pre>
<p>当<code>children</code>改变的时候，我们重新计算一次<code>childCount</code>，</p>
<pre class="language-dart"><code class="language-dart">@override
void didUpdateWidget(Switcher oldWidget) {
  var childrenChanged = (widget.children?.length ?? 0) != (oldWidget.children?.length ?? 0);
  if (widget._scrollDirection != oldWidget._scrollDirection || childrenChanged) {
    _initalizationElements();
    _initializationScroll();
  }
  super.didUpdateWidget(oldWidget);
}
</code></pre>
<p>这里判断如果是垂直模式，我们就<code>childCount++</code>，接下来，实现一下<code>build</code>方法：</p>
<pre class="language-dart"><code class="language-dart">@override
Widget build(BuildContext context) {
  if (_childCount == 0) {
    return widget.placeholder ?? SizedBox.shrink();
  }
  return LayoutBuilder(
    builder: (context, constraints) {
      return ConstrainedBox(
        constraints: constraints,
        child: ListView.separated(
          itemCount: _childCount,
          physics: NeverScrollableScrollPhysics(),
          controller: _controller,
          scrollDirection: widget._scrollDirection,
          padding: EdgeInsets.zero,
          itemBuilder: (context, index) {
            final child = widget.children[index % widget.children.length];
            return Container(
              alignment: Alignment.centerLeft,
              height: constraints.constrainHeight(),
              child: child,
            );
          },
          separatorBuilder: (context, index) {
            return SizedBox(
              width: widget.spacing,
            );
          },
        ),
      );
    },
  );
}
</code></pre>
<p>接下来实现垂直滚动的主要逻辑：</p>
<pre class="language-dart"><code class="language-dart">_animateVertical(double extent) {
  if (!_controller.hasClients || widget._scrollDirection != Axis.vertical) {
    return;
  }
  if (_selectedIndex == _childCount - 1) {
    _selectedIndex = 0;
    _controller.jumpTo(0);
  }
  _timer?.cancel();
  _timer = Timer(widget.delayedDuration, () {
    _selectedIndex++;
    var duration = _computeScrollDuration(extent);
    _controller.animateTo(extent * _selectedIndex, duration: duration, curve: widget.curve).whenComplete(() {
      _animateVertical(extent);
    });
  });
}
</code></pre>
<p>解释一下这段逻辑，先判断<code>ScrollController</code>有没有加载完成，然后当前的滚动方向是不是垂直的，不是就直接返回，然后当前的<code>index</code>是最后一个的时候，立马跳到第一个，<code>index</code>初始化为0，接下来，取消前一个定时器，开一个新的定时器，定时器的时间为我们传进来的间隔时间，然后每间隔<code>widget.delayedDuration</code>的时间滚动一次，这里调用<code>ScrollController.animateTo</code>，滚动距离为每个<code>item</code>的高度乘以当前的索引，滚动时间根据滚动速度算出来：</p>
<pre class="language-dart"><code class="language-dart">Duration _computeScrollDuration(double extent) {
  return Duration(milliseconds: (extent * Duration.millisecondsPerSecond / widget.scrollDelta).floor());
}
</code></pre>
<p>这里是我们小学就学过的，<code>距离 = 速度 x 时间</code>，所以根据距离和速度我们就可以得出需要的时间，这里乘以<code>Duration.millisecondsPerSecond</code>的原因是转换成毫秒，因为我们的速度是<code>pixels/second</code>。</p>
<p>当完成当前滚动的时候，进行下一次，这里递归调用<code>_animateVertical</code>，这样我们就实现了垂直的循环滚动。</p>
<h3 id="-8">水平模式</h3>
<p>接下去实现水平模式，和垂直模式类似：</p>
<pre class="language-dart"><code class="language-dart">_animateHorizonal(double extent, bool needsMoveToTop) {
  if (!_controller.hasClients || widget._scrollDirection != Axis.horizontal) {
    return;
  }
  _timer?.cancel();
  _timer = Timer(widget.delayedDuration, () {
    if (needsMoveToTop) {
      _controller.jumpTo(0);
      _animateHorizonal(extent, false);
    } else {
      var duration = _computeScrollDuration(extent);
      _controller.animateTo(extent, duration: duration, curve: widget.curve).whenComplete(() {
        _animateHorizonal(extent, true);
      });
    }
  });
}
</code></pre>
<p>这里解释一下<code>needsMoveToTop</code>，因为水平模式下，首尾都要停顿，所以我们加个参数判断下，如果是当前执行的滚动到头部的话，<code>needsMoveToTop</code>传<code>false</code>，如果是已经滚动到了尾部，<code>needsMoveToTop</code>传<code>true</code>，表示我们的下一次的行为是滚动到头部，而不是开始滚动到整个列表。</p>
<p>接下来我们看看在哪里开始滚动。</p>
<p>首先在页面加载的时候我们开始滚动，然后还有当方向和<code>childCount</code>改变的时候，重新开始滚动，所以：</p>
<pre class="language-dart"><code class="language-dart">@override
void initState() {
  super.initState();
  _initalizationElements();
  _initializationScroll();
}

@override
void didUpdateWidget(Switcher oldWidget) {
  var childrenChanged = (widget.children?.length ?? 0) != (oldWidget.children?.length ?? 0);
  if (widget._scrollDirection != oldWidget._scrollDirection || childrenChanged) {
    _initalizationElements();
    _initializationScroll();
  }
  super.didUpdateWidget(oldWidget);
}
</code></pre>
<p>然后是<code>_initializationScroll</code>方法：</p>
<pre class="language-dart"><code class="language-dart">_initializationScroll() {
  SchedulerBinding.instance.addPostFrameCallback((timeStamp) {
    if (!mounted) {
      return;
    }
    var renderBox = context?.findRenderObject() as RenderBox;
    if (!_controller.hasClients || _childCount == 0 || renderBox == null || !renderBox.hasSize) {
      return;
    }
    var position = _controller.position;
    _timer?.cancel();
    _timer = null;
    position.moveTo(0);
    _selectedIndex = 0;
    if (widget._scrollDirection == Axis.vertical) {
      _animateVertical(renderBox.size.height);
    } else {
      var maxScrollExtent = position.maxScrollExtent;
      _animateHorizonal(maxScrollExtent, false);
    }
  });
}
</code></pre>
<p>这里在页面绘制完成的时候，我们判断，如果<code>ScrollController</code>没有加载，<code>childCount == 0</code>或者大小没有计算完成的时候直接返回，然后获取<code>position</code>，取消上一个计时器，然后把列表滚到头部，<code>index</code>初始化为0，判断是垂直模式，开始垂直滚动，如果是水平模式开始水平滚动。</p>
<p><strong>这里注意，垂直滚动的时候，每次的滚动距离是每个item的高度，而水平滚动的时候，滚动距离是列表可滚动的最大长度</strong>。</p>
<p>到这里我们已经实现了Android的跑马灯，而且还增加了垂直滚动，是不是很简单呢。</p>
<p>如有问题、意见和建议，都可以在评论区里告诉我，我将及时修改和参考你的意见和建议，对代码做出优化。</p>
      </section>
      
        <section class="summary">
            <h2>Libraries</h2>
          <dl>
            <dt id="switcher">
              <span class="name"><a href="switcher/switcher-library.html">switcher</a></span>             
            </dt>
            <dd>
               
            </dd>
          </dl>
        </section>

  </div> <!-- /.main-content -->

  <div id="dartdoc-sidebar-right" class="col-xs-6 col-sm-6 col-md-2 sidebar sidebar-offcanvas-right">
  </div>

</main>

<footer>
  <span class="no-break">
    switcher
      1.0.0+1
  </span>

</footer>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="static-assets/typeahead.bundle.min.js"></script>
<script src="static-assets/highlight.pack.js"></script>
<script src="static-assets/URI.js"></script>
<script src="static-assets/script.js"></script>


</body>

</html>
